{
  "_args": [
    [
      {
        "raw": "protozero@https://registry.npmjs.org/protozero/-/protozero-1.4.5.tgz",
        "scope": null,
        "escapedName": "protozero",
        "name": "protozero",
        "rawSpec": "https://registry.npmjs.org/protozero/-/protozero-1.4.5.tgz",
        "spec": "https://registry.npmjs.org/protozero/-/protozero-1.4.5.tgz",
        "type": "remote"
      },
      "/opt/service"
    ]
  ],
  "_from": "protozero@>=1.4.2 <1.5.0",
  "_id": "protozero@1.4.5",
  "_inCache": true,
  "_location": "/protozero",
  "_phantomChildren": {},
  "_requested": {
    "raw": "protozero@https://registry.npmjs.org/protozero/-/protozero-1.4.5.tgz",
    "scope": null,
    "escapedName": "protozero",
    "name": "protozero",
    "rawSpec": "https://registry.npmjs.org/protozero/-/protozero-1.4.5.tgz",
    "spec": "https://registry.npmjs.org/protozero/-/protozero-1.4.5.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/",
    "/mapnik"
  ],
  "_resolved": "https://registry.npmjs.org/protozero/-/protozero-1.4.5.tgz",
  "_shasum": "80eaa80a4f9c751465c4cb2620d8233b50ec1aff",
  "_shrinkwrap": null,
  "_spec": "protozero@https://registry.npmjs.org/protozero/-/protozero-1.4.5.tgz",
  "_where": "/opt/service",
  "bugs": {
    "url": "https://github.com/mapbox/protozero/issues"
  },
  "dependencies": {},
  "description": "Minimalist protocol buffer decoder and encoder in C++",
  "devDependencies": {},
  "homepage": "https://github.com/mapbox/protozero#readme",
  "main": "include_dirs.js",
  "name": "protozero",
  "optionalDependencies": {},
  "readme": "# protozero\n\nMinimalistic protocol buffer decoder and encoder in C++.\n\nDesigned for high performance. Suitable for writing zero copy parsers and\nencoders with minimal need for run-time allocation of memory.\n\nLow-level: this is designed to be a building block for writing a very\ncustomized decoder for a stable protobuf schema. If your protobuf schema is\nchanging frequently or lazy decoding is not critical for your application then\nthis approach offers no value: just use the C++ API that can be generated with\nthe Google Protobufs `protoc` program.\n\n[![Travis Build Status](https://travis-ci.org/mapbox/protozero.svg?branch=master)](https://travis-ci.org/mapbox/protozero)\n[![Appveyor Build Status](https://ci.appveyor.com/api/projects/status/o354pq10y96mnr6d?svg=true)](https://ci.appveyor.com/project/Mapbox/protozero)\n[![Coverage Status](https://coveralls.io/repos/mapbox/protozero/badge.svg?branch=master&service=github)](https://coveralls.io/github/mapbox/protozero?branch=master)\n\n## Depends\n\n* C++11 compiler\n* Tests depend on the Google Protobuf library, but use of Protozero doesn't\n  need it\n\n\n## How it works\n\nThe protozero code does **not** read `.proto` files used by the usual Protobuf\nimplementations. The developer using protozero has to manually \"translate\" the\n`.proto` description into code. This means there is no way to access any of the\ninformation from the `.proto` description. This results in a few restrictions:\n\n* The names of the fields are not available.\n* Enum names are not available, you'll have to use the values they are defined\n  with.\n* Default values are not available.\n* Field types have to be hardcoded. The library does not know which types to\n  expect, so the user of the library has to supply the right types. Some checks\n  are made using `assert()`, but mostly the user has to take care of that.\n\nThe library will make sure not to overrun the buffer it was given, but\nbasically all other checks have to be made in user code!\n\n\n## Documentation\n\nYou have to have a working knowledge of how\n[protocol buffer encoding works](https://developers.google.com/protocol-buffers/docs/encoding).\n\n* Read the [tutorial](doc/tutorial.md) for an introduction on how to use\n  Protozero.\n* There is a table of all types and functions in the\n  [cheat sheet](doc/cheatsheet.md).\n* [Macros defined or used by Protozero](doc/macros.md).\n* Read the [upgrading instructions](UPGRADING.md) if you are upgrading from\n  an older version of Protozero.\n\nCall `make doc` to build the Doxygen-based reference documentation. (You'll\nneed [Doxygen](http://www.stack.nl/~dimitri/doxygen/) installed.) Then open\n`doc/html/index.html` in your browser to read it.\n\n\n## Installation\n\nCall `make install` to install include files in `/usr/include/protozero`. Call\n`make install DESTDIR=/usr/local` or similar to change install directory.\n\n\n## Limitations\n\n* A protobuf message has to fit into memory completely, otherwise it can not\n  be parsed with this library. There is no streaming support.\n* The length of a string, bytes, or submessage can't be more than 2^31-1.\n* The Google Protobuf spec documents that a non-repeated field can actually\n  appear several times in a message and the implementation is required to\n  return the value of the last version of that field in this case.\n  `pbf_reader.hpp` does not enforce this. If this feature is needed in your\n  case, you have to do this yourself.\n* There is no specific support for maps but they can be used as described in\n  the \"Backwards compatibility\" section of\n  https://developers.google.com/protocol-buffers/docs/proto3#maps.\n\n\n## Endianness\n\nProtozero uses a very simplistic test to check the byte order of the system it\ncompiles on. If this check is wrong, you'll get test failures. If this is the\ncase, please [open an issue](https://github.com/mapbox/protozero/issues) and\ntell us about your system.\n\n\n## Tests\n\nExtensive tests are included. Call\n\n    make test\n\nto build all tests and run them.\n\nSee `test/README.md` for more details about the test.\n\nYou can also use `gyp` to build the reader tests:\n\n    gyp gyp/protozero.gyp --depth=. --build=Release\n    ./out/Release/tests\n\nThis will clobber the `Makefile` from the repository! Instead of `Release` you\ncan use `Debug` for a debug build.\n\n\n## Coverage report\n\nTo get a coverage report compile and link with `--coverage`:\n\n    CXXFLAGS=\"--coverage\" LDFLAGS=\"--coverage\" make test\n\nIf you are using `g++` use `gcov` to generate a report (results are in `*.gcov`\nfiles):\n\n    gcov -lp test/*tests.o test/t/*/*test_cases.o\n\nIf you are using `clang++` use `llvm-cov` instead:\n\n    llvm-cov gcov -lp test/*tests.o test/t/*/*test_cases.o\n\nIf you are using `g++` you can use `gcovr` to generate nice HTML output:\n\n    mkdir -p coverage\n    gcovr -r . --html --html-details -o coverage/index.html\n\nOpen `coverage/index.html` in your browser to see the report.\n\n\n## Cppcheck\n\nFor extra checks with [Cppcheck](http://cppcheck.sourceforge.net/) you can call\n\n    make check\n\n\n## Who is using Protozero?\n\n* [Carmen](https://github.com/mapbox/carmen-cache)\n* [Libosmium](https://github.com/osmcode/libosmium)\n* [Mapbox GL Native](https://github.com/mapbox/mapbox-gl-native)\n* [Mapbox Vector Tile library](https://github.com/mapbox/vector-tile)\n* [Mapnik](https://github.com/mapbox/mapnik-vector-tile)\n* [OSRM](https://github.com/Project-OSRM/osrm-backend)\n* [Tippecanoe](https://github.com/mapbox/tippecanoe)\n\nAre you using Protozero? Tell us! Send a pull request with changes to this\nREADME.\n\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/mapbox/protozero.git"
  },
  "version": "1.4.5"
}
